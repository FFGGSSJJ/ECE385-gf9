module datapath (
    input logic Clk, Reset, 
    input logic LD_MAR, LD_MDR, LD_IR, LD_BEN, LD_CC, LD_REG, LD_PC, LD_LED,
    input logic GatePC, GateMDR, GateALU, GateMARMUX,
    input logic [1:0] PCMUX, ADDR2MUX, ALUK,
    input logic DRMUX, SR1MUX, SR2MUX, ADDR1MUX,
    input logic MIO_EN,             // In slc3 design, MIO_EN is ~OE, which is generated by state machine
    input logic [15:0] MDR_In,

    output logic BEN,       // nzp register
    output logic [11:0] LED,
    output logic [15:0] IR, 
    output logic [15:0] MAR,
    output logic [15:0] MDR, 
    output logic [15:0] PC
);
    logic [15:0] Bus;       // the data stored in bus line, 
                            // which should be connected to the output of MDR, ALU, PC and MAR(addr calculator)
                            // and inputs of PCMUX, REG_FILE, Logic in nzp, IR, MAR and MDRMUX

    logic [15:0] PC_In, PC_next;
    logic [15:0] addr1, addr2, addr_sum;    // address for the address calculator
    logic [15:0] SEXT0_10, SEXT0_8, SEXT0_5, SEXT0_4;// SEXTs seperated from IR
    logic [15:0] MDR_v;     // the MDR value into the MDR register
    logic [15:0] ALU_out;



    register reg_PC(.*, .Load(LD_PC), .data_in(PC_In), .data_out(PC));
    register reg_MAR(.*, .Load(LD_MAR), .data_in(Bus), .data_out(MAR));
    register reg_MDR(.*, .Load(LD_MDR), .data_in(MDR_v), .data_out(MDR));
    register reg_IR(.*, .Load(LD_IR), .data_in(Bus), .data_out(IR));

    mux_bus bus(.Gate({GateMARMUX, GatePC, GateALU, GateMDR}), .MAR_out(addr_sum), .PC_out(PC), .ALU_out(ALU_out), .MDR_out(MDR), 
                      .Out(Bus));
    mux4_1 mux_PC(.SEL(PCMUX), .A(PC_next), .B(addr_sum), .C(Bus), .D(16'b0), .Out(PC_In));
    mux2_1 mux_MDR(.SEL(MIO_EN), .A(MDR_In), .B(Bus), .Out(MDR_v));
    mux2_1 mux_ADDR1(.SEL(ADDR1MUX), .A(PC_next), .B(16'b0), .Out(addr1));  // B will be implemented later
    mux4_1 mux_ADDR2(.SEL(ADDR2MUX), .A(16'b0), .B(SEXT0_5), .C(SEXT0_8), .D(SEXT0_10), .Out(addr2));

    always_comb begin
        SEXT0_10 = {5'b0, IR[10:0]};
        SEXT0_8 = {7'b0, IR[8:0]};
        SEXT0_5 = {10'b0, IR[5:0]};
        addr_sum = addr1 + addr2;   // calculate the address
        
    end

    
endmodule