module datapath (
    input logic Clk, Reset, 
    input logic LD_MAR, LD_MDR, LD_IR, LD_BEN, LD_CC, LD_REG, LD_PC, LD_LED,
    input logic GatePC, GateMDR, GateALU, GateMARMUX,
    input logic [1:0] PCMUX, ADDR2MUX, ALUK,
    input logic DRMUX, SR1MUX, SR2MUX, ADDR1MUX,
    input logic MIO_EN,             // In slc3 design, MIO_EN is ~OE, which is generated by state machine
    input logic [15:0] MDR_In,

    output logic BEN,       // nzp register
    output logic [11:0] LED,
    output logic [15:0] IR, 
    output logic [15:0] MAR,
    output logic [15:0] MDR, 
    output logic [15:0] PC
);
    logic [15:0] Bus;       // the data stored in bus line, 
                            // which should be connected to the output of MDR, ALU, PC and MAR(addr calculator)
                            // and inputs of PCMUX, REG_FILE, Logic in nzp, IR, MAR and MDRMUX

    logic [15:0] PC_In, PC_next;
    logic [15:0] addr1, addr2, addr_sum;    // address for the address calculator
    logic [15:0] SEXT0_10, SEXT0_8, SEXT0_5, SEXT0_4;// SEXTs seperated from IR
    logic [15:0] MDR_v;     // the MDR value into the MDR register

    logic [2:0]  SR1MUX_out, DRMUX_out;
    logic [15:0] SR2MUX_out;
    logic [15:0] SR1out, SR2out;
    logic [15:0] ALU_out;   // output of ALU unit
    logic [2:0] nzp_val;
    logic N, Z, P;



    register reg_PC(.*, .Load(LD_PC), .data_in(PC_In), .data_out(PC));
    register reg_MAR(.*, .Load(LD_MAR), .data_in(Bus), .data_out(MAR));
    register reg_MDR(.*, .Load(LD_MDR), .data_in(MDR_v), .data_out(MDR));
    register reg_IR(.*, .Load(LD_IR), .data_in(Bus), .data_out(IR));

	 LED_reg reg_led(.*, .Load(LD_LED), .led_in(IR[11:0]), .led_out(LED));
    //logic_nzp reg_logic(.*, .data_in(Bus), .nzp(nzp_val));
    nzp_ff reg_nzp(.*, .Load(LD_CC), .nzp(nzp_val), .N(N), .Z(Z), .P(P));
    BR_COMP br_comp(.*, .Load(LD_BEN), .N(N), .Z(Z), .P(P), .comp_nzp(IR[11:9]), .BEN(BEN));

    mux_bus bus(.Gate({GateMARMUX, GatePC, GateALU, GateMDR}), .MAR_out(addr_sum), .PC_out(PC), .ALU_out(ALU_out), .MDR_out(MDR), 
                      .Out(Bus));
    mux4_1 mux_PC(.SEL(PCMUX), .A(PC_next), .B(addr_sum), .C(Bus), .D(16'b0), .Out(PC_In));
    mux2_1 mux_MDR(.SEL(MIO_EN), .A(Bus), .B(MDR_In), .Out(MDR_v));         // Bus is connected to 0(A)
    mux2_1 mux_ADDR1(.SEL(ADDR1MUX), .A(PC), .B(SR1out), .Out(addr1));  // B will be implemented later
    mux4_1 mux_ADDR2(.SEL(ADDR2MUX), .A(16'b0), .B(SEXT0_5), .C(SEXT0_8), .D(SEXT0_10), .Out(addr2));

    mux2_1 #(3) mux_SR1(.SEL(SR1MUX), .A(IR[8:6]), .B(IR[11:9]), .Out(SR1MUX_out));
    mux2_1 mux_SR2(.SEL(SR2MUX), .A(SR2out), .B(SEXT0_4), .Out(SR2MUX_out));
    mux2_1 #(3) mux_DR(.SEL(DRMUX), .A(IR[11:9]), .B(3'b111), .Out(DRMUX_out));

    ALU ALU_unit (.ALUK(ALUK), .A(SR1out), .B(SR2MUX_out), .ALU_out(ALU_out));
    reg_file register_file (.*, .Load(LD_REG), .DRMUX(DRMUX_out), .SR1(SR1MUX_out), .SR2(IR[2:0]), .Bus_in(Bus),
                            .SR1_out(SR1out), .SR2_out(SR2out));

	 SEXT sext_unit(.*);
    always_comb begin
        //SEXT0_10 = {5*{IR[10]}, IR[10:0]};
        //SEXT0_8 = {7*{IR[8]}, IR[8:0]};
        //SEXT0_5 = {10*{IR[5]}, IR[5:0]};
        //SEXT0_4 = {11*{IR[4]}, IR[4:0]};
      addr_sum = addr1 + addr2;   // calculate the address
		PC_next = PC + 1;
      if (Bus==16'h0000)
			nzp_val = 3'b010;
		else if(Bus[15]==1'b1)
			nzp_val = 3'b100;
		else
			nzp_val = 3'b001;
    end

    
endmodule